# coding=utf8
import requests
import random
import telebot
from telebot import types
from telebot.types import InlineKeyboardButton
import re
import pymongo
import cherrypy
from bson.objectid import ObjectId
from datetime import datetime, timedelta
import cherrypy_cors
from cherrypy.lib.httputil import parse_query_string
import sys

API_KEY = "YOUR API KEY"
bot = telebot.TeleBot(API_KEY)
client = pymongo.MongoClient(host="localhost", port=27017)
db = client["sudoku"]
games_coll = db.get_collection("games")
users_coll = db.get_collection("users")
pays_coll = db.get_collection("pays")
prices = {
    "40": 5000,
    "100": 11000,
    "200": 19000,
    "500": 38000,
    "1000": 69000
}



SAMPLE = [[1, 5, 2, 6, 3, 4],
          [4, 3, 6, 1, 2, 5],
          [2, 4, 5, 3, 1, 6],
          [6, 1, 3, 5, 4, 2],
          [3, 6, 4, 2, 5, 1],
          [5, 2, 1, 4, 6, 3]]

GUIDE = '‚òëÔ∏è ÿ±ÿßŸáŸÜŸÖÿß€å ÿ®ÿßÿ≤€å ŸÖÿ≠ÿ®Ÿàÿ® ÿ≥ŸàÿØŸà⁄©Ÿàüî¢\n\n‚úåÔ∏è €å⁄© ÿ®ÿßÿ≤€å ÿ¨ÿØŸàŸÑ ÿßÿπÿØÿßÿØ ŸÖÿπÿ±ŸàŸÅ ÿ®Ÿá ŸÖ€åŸÜ€å ÿ≥ŸàÿØŸà⁄©Ÿà €åÿß ÿ≥ŸàÿØŸà⁄©Ÿà€å ⁄©Ÿà⁄Ü⁄© ⁄©Ÿá 6 ÿ≥ÿ∑ÿ± Ÿà 6 ÿ≥ÿ™ŸàŸÜ ÿØÿßÿ±ÿØ\n\nÿ±Ÿàÿ¥ ÿ®ÿßÿ≤€å: ÿØÿ± ÿß€åŸÜ ÿ®ÿßÿ≤€å ŸÖ€å ÿ®ÿß€åÿ≥ÿ™ ÿßÿπÿØÿßÿØ 1 Ÿà 2 Ÿà 3 Ÿà 4 Ÿà 5 Ÿà 6  ÿ±ÿß ŸÖÿ∑ÿßÿ®ŸÇ ÿ¥⁄©ŸÑ ÿ®Ÿá ⁄ØŸàŸÜŸá ÿß€å ÿØÿ± ÿ¨ÿØŸàŸÑ ŸÇÿ±ÿßÿ± ÿØŸá€åÿØ ⁄©Ÿá Ÿá€å⁄Ü ÿπÿØÿØ ÿ™⁄©ÿ±ÿßÿ±€å ÿØÿ± ÿ≥ÿ™ŸàŸÜÿå ÿ≥ÿ∑ÿ± Ÿà ŸáŸÖ⁄ÜŸÜ€åŸÜ ŸÖÿ≥ÿ™ÿ∑€åŸÑ Ÿáÿß€å ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá ŸÜÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥€åŸÖ\n\nüî≤üî≤üî≤‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏è\nüî≤üî≤üî≤‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏è\n‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏èüî≤üî≤üî≤\n‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏èüî≤üî≤üî≤\nüî≤üî≤üî≤‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏è\nüî≤üî≤üî≤‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏è\n\n\nÿßŸÜŸàÿßÿπ ÿ®ÿßÿ≤€å: ÿß€åŸÜ ÿ®ÿßÿ≤€å ÿ±ÿß ŸáŸÖ ÿ®Ÿá ÿµŸàÿ±ÿ™ ÿ™⁄© ŸÜŸÅÿ±Ÿá ÿØÿßÿÆŸÑ ÿ±ÿ®ÿßÿ™ Ÿà ŸáŸÖ ÿ®Ÿá ÿµŸàÿ±ÿ™ ⁄ÜŸÜÿØ ŸÜŸÅÿ±Ÿá(ÿØŸàÿ≥ÿ™ÿßŸÜ) ÿØÿ± ⁄Øÿ±ŸàŸáŸáÿßÿå ⁄©ÿßŸÜÿßŸÑ €åÿß Ÿæ€åŸà€å ŸÖ€åÿ™ŸàÿßŸÜ€åÿØ ÿßŸÜÿ¨ÿßŸÖ ÿØŸá€åÿØ.\nÿ®ÿßÿ≤€å ÿØŸàÿ≥ÿ™ÿßŸÜŸá ÿØÿ± ÿ≥Ÿá ÿ≠ÿßŸÑÿ™ ÿ≥ÿßÿØŸáÿå ŸÖÿ™Ÿàÿ≥ÿ∑ Ÿà ÿ≥ÿÆÿ™ ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ÿßÿ≥ÿ™.\nÿ¨Ÿáÿ™ ÿßŸÜÿ¨ÿßŸÖ ÿ®ÿßÿ≤€å ÿØŸàÿ≥ÿ™ÿßŸÜŸá ⁄©ÿßŸÅ€åÿ≥ÿ™ ÿßÿ≤ ÿ∑ÿ±€åŸÇ ŸÖŸÜŸà Ÿà ÿØ⁄©ŸÖŸá    ÿ®ÿßÿ≤€å ÿ®ÿß ÿØŸàÿ≥ÿ™ÿßŸÜ ÿßŸÇÿØÿßŸÖ ŸÜŸÖÿß€å€åÿØ €åÿß ÿßÿ≤ ÿ∑ÿ±€åŸÇ ÿ™ÿß€åŸæ ÿ¢ÿØÿ±ÿ≥ ÿ±ÿ®ÿßÿ™ ÿØÿ± ŸÖ⁄©ÿßŸÜ€å ⁄©Ÿá ŸÇÿµÿØ ÿ®ÿßÿ≤€å ÿØÿßÿ±€åÿØ\n\nÿßŸÖÿ™€åÿßÿ≤ : Ÿáÿ± ÿπÿØÿØ ÿØÿ±ÿ≥ÿ™ 3 ÿßŸÖÿ™€åÿßÿ≤ ŸÖÿ´ÿ®ÿ™  Ÿà ÿπÿØÿØ ÿ∫ŸÑÿ∑ 2 ÿßŸÖÿ™€åÿßÿ≤ ŸÖŸÜŸÅ€å\nŸÑÿßÿ≤ŸÖ ÿ®Ÿá ÿ∞⁄©ÿ± ÿßÿ≥ÿ™ ⁄©Ÿá ÿßŸÖÿ™€åÿßÿ≤ ÿ®ÿßÿ≤€åŸáÿß€å ÿßŸÜŸÅÿ±ÿßÿØ€å ÿØÿßÿÆŸÑ ÿ±ÿ®ÿßÿ™ÿå ÿ™ÿßÿ´€åÿ±€å ÿØÿ± ÿ±ÿ™ÿ®Ÿá Ÿà ÿßÿ±ÿ™ŸÇÿß ÿ≥ÿ∑ÿ≠ ŸÜÿØÿßÿ±ÿØ.\n\nÿ±ÿßŸáŸÜŸÖÿß Ÿà ÿ¢€åÿ™ŸÖ: \nÿ¢€åÿ™ŸÖ ÿ¨ÿßÿ±Ÿà ⁄©Ÿá €å⁄© ÿÆÿßŸÜŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ÿ±ÿØŸá Ÿà ÿπÿØÿØ ÿµÿ≠€åÿ≠ ÿ¢ŸÜ ÿÆÿßŸÜŸá ÿ™Ÿàÿ≥ÿ∑ ÿ±ÿ®ÿßÿ™ ÿ®Ÿá ŸÜŸÅÿπ ÿ¥ŸÖÿß ⁄Øÿ∞ÿßÿ¥ÿ™Ÿá ŸÖ€å ÿ¥ŸàÿØ\nÿ¢€åÿ™ŸÖ ÿ¨Ÿáÿ¥ ⁄©Ÿá ÿπÿØÿØ ÿµÿ≠€åÿ≠ €å⁄© ÿÆÿßŸÜŸá ÿ®Ÿá ÿßŸÜÿ™ÿÆÿßÿ® ÿÆŸàÿØ ÿ±ÿ®ÿßÿ™ ÿ®Ÿá ŸÜŸÅÿπ ÿ¥ŸÖÿß ŸÇÿ±ÿßÿ± ÿØÿßÿØŸá ŸÖ€å ÿ¥ŸàÿØ.\nŸÑÿßÿ≤ŸÖ ÿ®Ÿá ÿ∞⁄©ÿ± ÿßÿ≥ÿ™ ⁄©Ÿá ÿØÿ± Ÿáÿ± ÿ®ÿßÿ≤€å ŸÅŸÇÿ∑ €å⁄© ÿ®ÿßÿ± ŸÖÿ¨ÿßÿ≤ ÿ®Ÿá ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ÿ¢€åÿ™ŸÖ Ÿà ÿ¢ŸÜ ŸáŸÖ ÿ®Ÿá ÿ¥ÿ±ÿ∑ ÿØÿßÿ¥ÿ™ŸÜ ÿ≥⁄©Ÿá Ÿáÿ≥ÿ™€åÿØ.\n\nü§ñ @MiniSudokuBot\nüì£ @TRexGames'
LEVELS = [50, 105, 165, 231, 304, 384, 472, 569, 676, 793, 922, 1064, 1220, 1392, 1581, 1789, 2018, 2270, 2547, 2852,
          3188, 3558, 3965, 4412, 4904, 5445, 6040, 6695, 7416, 8209, 9081, 10040, 11095, 12256, 13533, 14938, 16483,
          18183, 20053, 22110, 24372, 26861, 29599, 32611, 35924, 39568, 43576, 47985, 52835, 58170, 64039, 70495,
          77597, 85409, 94002, 103454, 113852, 125290, 137871, 151711, 166935, 183681, 202102, 222365, 244654, 269172,
          296142, 325809, 358443, 394340, 433827, 477263, 525042, 577599, 635412, 699006, 768960, 845909, 930553,
          1023662, 1126082, 1238744, 1362672, 1498993, 1648946, 1813894, 1995337, 2194924, 2414470, 2655971, 2921622,
          3213838, 3535275, 3888856, 4277795, 4705628, 5176245, 5693923, 6263369, 6889760]





def check_column(sudoku, tmp, j):
    isInColumn = False
    for k in range(0, len(sudoku)):
        if tmp == sudoku[k][j]:
            isInColumn = True
    return isInColumn


def print_sudoku(sudoku):
    for row in sudoku:
        for number in row:
            print(number, end=" ")
        print()
    print("========")


def check_surroundings(sudoku, i, j, tmp):
    if i == 0 or i == 2 or i == 4:
        return False
    else:
        if (j == 0 or j == 3) and (tmp == sudoku[i - 1][j + 1] or tmp == sudoku[i - 1][j + 2]):
            return True
        elif (j == 1 or j == 4) and (tmp == sudoku[i - 1][j - 1] or tmp == sudoku[i - 1][j + 1]):
            return True
        elif (j == 2 or j == 5) and (tmp == sudoku[i - 1][j - 1] or tmp == sudoku[i - 1][j - 2]):
            return True
        else:
            return False
    return False


def check_surroundings2(sudoku, i, j, tmp):
    elements = []
    tmp_i = (i // 2) * 2
    tmp_j = (j // 3) * 3
    for m in range(0, 2):
        tmp_i += m
        for n in range(0, 3):
            if i == tmp_i and tmp_j == j:
                continue
            elements.append(sudoku[tmp_i][tmp_j + n])
    if tmp in elements:
        return True
    return False


def init_random_arr(arr):
    for i in random.randint(0, 35):
        if i not in arr:
            arr.append(i)


def arr_copy(src, dst):
    for i, row in enumerate(src):
        dst.append([])
        for element in row:
            dst[i].append(element)


def solve_sudoku(sudoku, i, j, counter):
    if i == -1 and j == -1:
        return counter
    for k in range(0, 6):
        if check_column(sudoku, k + 1, j) or check_surroundings2(sudoku, i, j, k + 1) or ((k + 1) in sudoku[i]):
            continue
        else:
            sudoku[i][j] = k + 1
            sudoku_copy = []
            arr_copy(sudoku, sudoku_copy)
            indices = get_zero_index(sudoku_copy)
            if indices == [-1, -1]:
                counter += 1
            else:
                counter = solve_sudoku(sudoku_copy, indices[0], indices[1], counter)
    return counter


def randomize(sudoku, type):
    indices = [x for x in range(36)]
    counter = 0
    if type == 'e':
        counter = 8
    if type == 'm':
        counter = 5
    tmp_sudoku = []
    arr_copy(sudoku, tmp_sudoku)
    random.shuffle(indices)
    for x in indices:
        i = x // 6
        j = x % 6
        tmp = sudoku[i][j]
        sudoku[i][j] = 0
        zero_indices = get_zero_index(sudoku)
        sudoku_copy = []
        arr_copy(sudoku, sudoku_copy)
        if solve_sudoku(sudoku_copy, zero_indices[0], zero_indices[1], 0) > 1:
            sudoku[i][j] = tmp
    if type == 'h':
        return sudoku
    random.shuffle(indices)
    while counter != 0:
        x = indices.pop()
        i = x // 6
        j = x % 6
        if sudoku[i][j] != 0:
            counter += 1
        sudoku[i][j] = tmp_sudoku[i][j]
        counter -= 1
    return sudoku


def get_zero_index(sudoku):
    for i, row in enumerate(sudoku):
        for j, element in enumerate(row):
            if element == 0:
                return [i, j]
    return [-1, -1]


def get_total_rank(users, id):
    previous_rank = 0
    previous_point = 0
    for i, user in enumerate(users):
        if i == 0:
            previous_rank = 1
            previous_point = user["total_point"]
        elif previous_point != user["total_point"]:
            previous_point = user["total_point"]
            previous_rank += 1
        if user["_id"] == id:
            return previous_rank
    return ''


def return_character(number):
    if number == 0:
        return "0Ô∏è‚É£"
    elif number == 1:
        return "1Ô∏è‚É£"
    elif number == 2:
        return "2Ô∏è‚É£"
    elif number == 3:
        return "3Ô∏è‚É£"
    elif number == 4:
        return "4Ô∏è‚É£"
    elif number == 5:
        return "5Ô∏è‚É£"
    elif number == 6:
        return "6Ô∏è‚É£"
    elif number == 7:
        return "7Ô∏è‚É£"
    elif number == 8:
        return "8Ô∏è‚É£"
    elif number == 9:
        return "9Ô∏è‚É£"


def create_keyboards(sudoku, game_id):
    keyboards = []
    for i, row in enumerate(sudoku):
        keyboards_row = []
        for j, number in enumerate(row):
            if number != 0:
                if (i == 2 or i == 3) and j < 3:
                    keyboards_row.append(
                        InlineKeyboardButton(number, callback_data="s" + str(i) + "" + str(j) + "/" + game_id))
                elif (i == 0 or i == 1) and j >= 3:
                    keyboards_row.append(
                        InlineKeyboardButton(number, callback_data="s" + str(i) + "" + str(j) + "/" + game_id))
                elif (i == 4 or i == 5) and j >= 3:
                    keyboards_row.append(
                        InlineKeyboardButton(number, callback_data="s" + str(i) + "" + str(j) + "/" + game_id))
                else:
                    keyboards_row.append(
                        InlineKeyboardButton(return_character(number),
                                             callback_data="s" + str(i) + "" + str(j) + "/" + game_id))
            else:
                if (i == 2 or i == 3) and j < 3:
                    keyboards_row.append(
                        InlineKeyboardButton("‚¨úÔ∏è", callback_data="s" + str(i) + "" + str(j) + "/" + game_id))
                elif (i == 0 or i == 1) and j >= 3:
                    keyboards_row.append(
                        InlineKeyboardButton("‚¨úÔ∏è", callback_data="s" + str(i) + "" + str(j) + "/" + game_id))
                elif (i == 4 or i == 5) and j >= 3:
                    keyboards_row.append(
                        InlineKeyboardButton("‚¨úÔ∏è", callback_data="s" + str(i) + "" + str(j) + "/" + game_id))
                else:
                    keyboards_row.append(
                        InlineKeyboardButton("üî≤", callback_data="s" + str(i) + "" + str(j) + "/" + game_id))
        keyboards.append(keyboards_row)

    empty = []
    empty.append(InlineKeyboardButton("Ô∏èÔ∏è", callback_data="empty"))
    keyboards.append(empty)
    numbers = []
    for i in range(0, 6):
        numbers.append(InlineKeyboardButton(return_character(i + 1), callback_data="n" + str(i + 1) + "/" + game_id))
    keyboards.append(numbers)
    items = []
    items.append(InlineKeyboardButton('ÿ¨ÿßÿ±Ÿàüßπ', callback_data='broom/' + game_id))
    items.append(InlineKeyboardButton('ÿ¨Ÿáÿ¥üí•', callback_data='jump/' + game_id))
    keyboards.append(items)
    keyboards.append([InlineKeyboardButton(' ü§ù ÿ®ÿßÿ≤€å ÿ®ÿß ÿØŸàÿ≥ÿ™ÿßŸÜŸÖ(⁄Øÿ±ŸàŸáÿå ⁄©ÿßŸÜÿßŸÑ Ÿà ...) ü§ù', switch_inline_query="")])
    return types.InlineKeyboardMarkup(keyboards)


def create_finish_keyboards(sudoku):
    keyboards = []
    for i, row in enumerate(sudoku):
        keyboards_row = []
        for j, number in enumerate(row):
            if (i == 2 or i == 3) and j < 3:
                keyboards_row.append(
                    InlineKeyboardButton(number, url="t.me/MiniSudokuBot"))
            elif (i == 0 or i == 1) and j >= 3:
                keyboards_row.append(
                    InlineKeyboardButton(number, url="t.me/MiniSudokuBot"))
            elif (i == 4 or i == 5) and j >= 3:
                keyboards_row.append(
                    InlineKeyboardButton(number, url="t.me/MiniSudokuBot"))
            else:
                keyboards_row.append(
                    InlineKeyboardButton(return_character(number), url="t.me/MiniSudokuBot"))
        keyboards.append(keyboards_row)
    keyboards.append([InlineKeyboardButton('üõí ŸÅÿ±Ÿàÿ¥⁄ØÿßŸá', callback_data='shop'),
                      InlineKeyboardButton('üîÅ ÿØŸàÿ®ÿßÿ±Ÿá', switch_inline_query_current_chat="")])
    keyboards.append([InlineKeyboardButton(' ü§ù ÿ®ÿßÿ≤€å ÿ®ÿß ÿØŸàÿ≥ÿ™ÿßŸÜŸÖ(⁄Øÿ±ŸàŸáÿå ⁄©ÿßŸÜÿßŸÑ Ÿà ...) ü§ù', switch_inline_query="")])
    keyboards.append([InlineKeyboardButton('üéÆüü° ÿ®ÿßÿ≤€åŸáÿß€å ÿ™€åÿ±⁄©ÿ≥ üü°üéÆ', url='https://t.me/TRexGames/599')])
    return types.InlineKeyboardMarkup(keyboards)


def create_sudoku(game_id, type):
    while True:
        sudoku = []
        reset = False
        for i in range(0, 6):
            row = []
            numbers = [1, 2, 3, 4, 5, 6]
            for j in range(0, 6):
                tmp = numbers[random.randint(0, len(numbers) - 1)]
                tmp_numbers = numbers[:]
                while tmp in row or check_column(sudoku, tmp, j) or check_surroundings(
                        sudoku, i, j, tmp):
                    tmp_numbers.remove(tmp)
                    if (len(tmp_numbers) == 0): break
                    tmp = tmp_numbers[random.randint(0, len(tmp_numbers) - 1)]
                if len(tmp_numbers) == 0:
                    reset = True
                    break
                row.append(tmp)
                numbers.remove(tmp)
            if reset:
                break
            sudoku.append(row)
        if reset:
            continue
        print_sudoku(sudoku)
        games_coll.update_one({"_id": game_id}, {"$set": {"sudoku": sudoku}})
        randomize(sudoku, type)
        print_sudoku(sudoku)
        sudoku_copy = []
        arr_copy(sudoku, sudoku_copy)
        games_coll.update_one({"_id": game_id}, {"$set": {"randomized_sudoku": sudoku}})
        return create_keyboards(sudoku, str(game_id))


def single_player_sudoku(message, game_id):
    bot.send_message(message.chat.id,
                     "üî¢ ŸÖ€åŸÜ€å ÿ≥ŸàÿØŸà⁄©Ÿà üî¢\n\nüìöŸÇÿ±ÿßÿ±ÿØÿßÿØŸÜ ÿßÿπÿØÿßÿØ 1 ÿ™ÿß 6 ÿØÿ± ÿ¨ÿØŸàŸÑ ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿØÿ± ÿ≥ÿ∑ÿ±ÿå ÿ≥ÿ™ŸàŸÜ Ÿà ŸÖÿ≥ÿ™ÿ∑€åŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá\nüíé ÿ®ÿßÿ≤€å ÿßŸÜŸÅÿ±ÿßÿØ€å\n\nüî∞ÿßŸÖÿ™€åÿßÿ≤ÿßÿ™\n" + create_text(
                         games_coll.find_one({"_id": ObjectId(game_id)})["users"]) + '\nü§ñ@MiniSudokuBot',
                     reply_markup=create_sudoku(game_id, 'e'))


def create_text(users):
    text = ''
    points = {}
    for i in users:
        if len(users[i]["moves"]) == 0:
            points[i] = 0
        else:
            point = 0
            for x in users[i]["moves"]:
                point += x["point"]
            points[i] = point
    points = dict(sorted(points.items(), key=lambda x: x[1], reverse=True))
    previous_point = next(iter(points.values()))
    previous_rank = 1
    for i, id in enumerate(points):
        line = u'\u200e'
        user = users_coll.find_one({"_id": int(id)})
        if i == 0:
            line = return_character(1)
        elif i != 0 and points[id] == previous_point:
            for x in str(previous_rank):
                line += return_character(int(x))
        else:
            previous_point = points[id]
            previous_rank += 1
            for x in str(previous_rank):
                line += return_character(int(x))
        line += u'\u200e'+ user["first_name"] + '  üéñ' + u'\u200e'+ str(user["total_rank"]) + '\n' + "üî∞" + str(points[id]) + '  „ÄΩÔ∏è' + str(
            user["level"]) + "\n\n"
        text = line + text
        if i >= 25:
            text = "Ÿà " + str(len(points) - 25) + " ŸÜŸÅÿ± ÿØ€å⁄Øÿ± ...\n" + text
            break
    return text


def games_count(user_id):
    count = games_coll.count_documents({"users." + str(user_id): {"$exists": True}})
    return str(count)


def get_past_seven_rank(games, user_id):
    points = {}
    for game in games:
        for user in game["users"]:
            for move in game["users"][user]["moves"]:
                if user not in points:
                    points[user] = 0
                else:
                    points[user] += move["point"]
    points = dict(sorted(points.items(), key=lambda x: x[1], reverse=True))
    if user_id not in list(points.keys()):
        return ''
    return str(list(points.keys()).index(user_id) + 1)


def get_past_seven_points(moves, user_id):
    point = 0
    for move_arr in moves:
        for i in move_arr["users"][user_id]["moves"]:
            point += i["point"]
    return str(point)


def update_profiles(users, game_id):
    print('ended!-4-1 ' + str(game_id))
    for i in users:
        total_points = users_coll.find_one({"_id": int(i)})["total_point"]
        print('ended!-4-2 ' + str(game_id))
        for point in users[i]["moves"]:
            total_points += point["point"]
        print('ended!-4-2-1 ' + str(game_id))
        users_coll.update_one({"_id": int(i)}, {"$set": {"total_point": total_points}})
        print('ended!-4-2-2 ' + str(game_id))
        for j, level in enumerate(LEVELS):
            print('ended!-4-2-3 ' + str(game_id))
            if total_points < level:
                print('ended!-4-2-4 ' + str(game_id))
                if users_coll.find_one({"_id": int(i)})["level"] < (j):
                    print('ended!-4-2-5 ' + str(game_id))
                    try:
                        bot.send_message(chat_id=int(i), text="üí™ÿß€åŸàŸÑ " + users_coll.find_one({"_id": int(i)})[
                            "first_name"] + "\nÿ™ÿ®ÿ±€å⁄©!üéä  ÿ≥ÿ∑ÿ≠ ÿ¥ŸÖÿß ÿ®Ÿá " + str(
                            j) + " ÿßÿ±ÿ™ŸÇÿß €åÿßŸÅÿ™ Ÿà 10 ÿ≥⁄©Ÿá ŸáÿØ€åŸá ⁄Øÿ±ŸÅÿ™€å\nüï∫üï∫üíÉüíÉ")
                        print('ended!-4-2-6 ' + str(game_id))
                        users_coll.update_one({"_id": int(i)},
                                              {"$set": {"total_point": total_points, "level": (j)},
                                               "$inc": {"coins": 10}})
                    except Exception as e:
                        print(e)
                    print('ended!-4-2-7 ' + str(game_id))
                break
    print('ended!-4-3 ' + str(game_id))
    for i in users:
        users_coll.update_one({"_id": int(i)}, {
            "$set": {"total_rank": get_total_rank(users_coll.find().sort("total_point", -1), int(i))}})
    print('ended!-4-4 ' + str(game_id))


def get_total_ranking(users):
    text = 'ÿ±ŸÜ⁄©€åŸÜ⁄Ø ÿßŸÖÿ™€åÿßÿ≤ ⁄©ŸÑ\n\n'
    counter = 1
    for i, user in enumerate(users):
        if user["total_rank"] == '':
            counter -= 1
            continue
        text += u'\u200e' + str(counter) + ". " + u'\u200e' + user["first_name"] + '  ' + u'\u200e' + str(
            user["total_point"]) + '\n'
        counter += 1
    text += '\nü§ñ @MiniSudokuBot\nüì£ @TRexGames'
    return text


def get_seven_ranking(games):
    points = {}
    for game in games:
        for user in game["users"]:
            for move in game["users"][user]["moves"]:
                if user not in points:
                    points[user] = 0
                else:
                    points[user] += move["point"]
    points = dict(sorted(points.items(), key=lambda x: x[1], reverse=True))
    text = 'ÿ±ŸÜ⁄©€åŸÜ⁄Ø ŸáŸÅÿ™ ÿ±Ÿàÿ≤ ÿßÿÆ€åÿ±\n\n'
    for i, user in enumerate(points):
        if users_coll.find_one({"_id": int(user)}):
            text += u'\u200e' + str(i + 1) + ". " + u'\u200e' + \
                    users_coll.find_one({"_id": int(user)}, {"first_name": 1})[
                        "first_name"] + '   ' + u'\u200e' + str(points[user]) + "\n"
    text += '\nü§ñ @MiniSudokuBot\nüì£ @TRexGames'
    return text


@bot.message_handler(commands=['start'])
def start(message):
    print("start", message)
    if '/start shop' == message.text:
        text = 'üõí ŸÅÿ±Ÿàÿ¥⁄ØÿßŸá\n\nüìöŸáÿ± ÿ±ÿßŸáŸÜŸÖÿß€å ÿ¨ÿßÿ±Ÿà  €åÿß ÿ¨Ÿáÿ¥  5 ÿ≥⁄©Ÿá ŸÜ€åÿßÿ≤ ÿØÿßÿ±ÿØ\n\nüëáÿ®ÿ±ÿß€å ÿÆÿ±€åÿØ ÿ≥⁄©Ÿá €å⁄©€å ÿßÿ≤ ŸÖŸàÿßÿ±ÿØ ÿ≤€åÿ± ÿ±ÿß ' \
               'ÿßŸÜÿ™ÿÆÿßÿ® ŸÜŸÖÿß€å€åÿØüëá '
        markup = types.InlineKeyboardMarkup(row_width=1).add(
            types.InlineKeyboardButton('üí∞ 40 ÿ≥⁄©Ÿáüí∞ üëà 5000 ÿ™ŸàŸÖÿßŸÜ', callback_data='c40'),
            types.InlineKeyboardButton('üí∞ 100 ÿ≥⁄©Ÿáüí∞ üëà 11000 ÿ™ŸàŸÖÿßŸÜ', callback_data='c100'),
            types.InlineKeyboardButton('üí∞ 200 ÿ≥⁄©Ÿáüí∞ üëà 19000 ÿ™ŸàŸÖÿßŸÜ', callback_data='c200'),
            types.InlineKeyboardButton('üí∞ 500 ÿ≥⁄©Ÿáüí∞ üëà 38000 ÿ™ŸàŸÖÿßŸÜ', callback_data='c500'),
            types.InlineKeyboardButton('üí∞ 1000 ÿ≥⁄©Ÿáüí∞ üëà 69000 ÿ™ŸàŸÖÿßŸÜ', callback_data='c1000')
        )
        bot.send_message(chat_id=message.chat.id, text=text, reply_markup=markup)
        return
    try:
        if len(message.from_user.first_name) > 20:
            message.from_user.first_name = message.from_user.first_name[0:20]
        users_coll.insert_one(
            {"_id": message.from_user.id, "first_name": message.from_user.first_name, "total_point": 0, "coins": 20,
             "level": 0, "total_rank": ''})
    except Exception as e:
        print(e)
    markup = types.ReplyKeyboardMarkup(row_width=2)
    single_player_btn = types.KeyboardButton("üèÜ ÿ®ÿßÿ≤€å ÿ™⁄© ŸÜŸÅÿ±Ÿá")
    multi_player_btn = types.KeyboardButton("ü§ù ÿ®ÿßÿ≤€å ⁄ÜŸÜÿØ ŸÜŸÅÿ±Ÿá")
    profile_btn = types.KeyboardButton("üë§ Ÿæÿ±ŸàŸÅÿß€åŸÑ")
    champions_btn = types.KeyboardButton("üèÖ ŸÇŸáÿ±ŸÖÿßŸÜÿßŸÜ")
    shop_btn = types.KeyboardButton("üõí ŸÅÿ±Ÿàÿ¥⁄ØÿßŸá")
    guide_btn = types.KeyboardButton("üìö ÿ±ÿßŸáŸÜŸÖÿß")
    markup.add(single_player_btn, multi_player_btn, profile_btn, champions_btn, shop_btn, guide_btn)
    bot.send_message(message.chat.id, "ÿ®Ÿá ÿ®ÿßÿ≤€å ÿ≥ŸàÿØŸà⁄©Ÿà ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ", reply_markup=markup)


@bot.message_handler()
def menu(message):
    print("message", message)
    try:
        if len(message.from_user.first_name) > 20:
            message.from_user.first_name = message.from_user.first_name[0:20]
        users_coll.insert_one(
            {"_id": message.from_user.id, "first_name": message.from_user.first_name, "total_point": 0, "coins": 20,
             "level": 0, "total_rank": ''})
    except Exception as e:
        print(e)
    if message.text == "üèÜ ÿ®ÿßÿ≤€å ÿ™⁄© ŸÜŸÅÿ±Ÿá":
        if bot.get_chat_member(-1001319848880, message.from_user.id).status == 'left':
            markup = types.InlineKeyboardMarkup().add(
                types.InlineKeyboardButton("ÿπÿ∂Ÿà€åÿ™ ÿØÿ± ⁄©ÿßŸÜÿßŸÑ", url="https://t.me/TRexGames"))
            bot.send_message(message.chat.id,
                             "⁄©ÿßÿ±ÿ®ÿ± " + message.from_user.first_name + "\nÿ®ÿ±ÿß€å ÿ≥ÿßÿÆÿ™ ÿ®ÿßÿ≤€å ÿßÿ®ÿ™ÿØÿß ÿπÿ∂Ÿà ⁄©ÿßŸÜÿßŸÑ ÿ≤€åÿ± ÿ¥Ÿà€åÿØ üëá\n@TRexGames",
                             reply_markup=markup)
            return
        game_id = games_coll.insert_one(
            {"mode": "single", "type": "easy", "is_complete": 0, "date": datetime.today().replace(microsecond=0),
             "users": {str(message.from_user.id): {"moves": [], "username": message.from_user.first_name, "jump": 0,
                                                   "broom": 0, "use_broom": 0}}}).inserted_id
        single_player_sudoku(message, game_id)
    elif message.text == "ü§ù ÿ®ÿßÿ≤€å ⁄ÜŸÜÿØ ŸÜŸÅÿ±Ÿá":
        if bot.get_chat_member(-1001319848880, message.from_user.id).status == 'left':
            markup = types.InlineKeyboardMarkup().add(
                types.InlineKeyboardButton("ÿπÿ∂Ÿà€åÿ™ ÿØÿ± ⁄©ÿßŸÜÿßŸÑ", url="https://t.me/TRexGames"))
            bot.send_message(message.chat.id,
                             "⁄©ÿßÿ±ÿ®ÿ± " + message.from_user.first_name + "\nÿ®ÿ±ÿß€å ÿ≥ÿßÿÆÿ™ ÿ®ÿßÿ≤€å ÿßÿ®ÿ™ÿØÿß ÿπÿ∂Ÿà ⁄©ÿßŸÜÿßŸÑ ÿ≤€åÿ± ÿ¥Ÿà€åÿØ üëá\n@TRexGames",
                             reply_markup=markup)
            return
        markup = types.InlineKeyboardMarkup().add(
            types.InlineKeyboardButton("€å⁄© ⁄Øÿ±ŸàŸá ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ", switch_inline_query=""))
        bot.send_message(message.chat.id, "ÿ®ÿ±ÿß€å ÿ®ÿßÿ≤€å ⁄ÜŸÜÿØ ŸÜŸÅÿ±Ÿá ÿ®ÿ± ÿ±Ÿà€å ÿØ⁄©ŸÖŸá €å ÿ≤€åÿ± ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ : ", reply_markup=markup)
    elif message.text == "üë§ Ÿæÿ±ŸàŸÅÿß€åŸÑ":
        user = users_coll.find_one({"_id": message.from_user.id})
        text = 'Ÿæÿ±ŸàŸÅÿß€åŸÑ\n\n' + 'üë§ŸÜÿßŸÖ   üëà ' + user["first_name"] + '\nüíéÿ≥ÿ∑ÿ≠  üëà ' + str(
            user["level"]) + '\nüî∞ ÿ™ÿπÿØÿßÿØ ÿ®ÿßÿ≤€å  üëà ' + str(games_coll.count_documents(
            {"users." + str(message.from_user.id): {"$exists": True}})) + '\n„ÄΩÔ∏è ÿßŸÖÿ™€åÿßÿ≤ ÿ™ÿß ÿ≥ÿ∑ÿ≠ ÿ®ÿπÿØ  üëà ' + str(
            LEVELS[user["level"]] - user["total_point"]) + '\nüéñ ÿ±ÿ™ÿ®Ÿá üëà ' + str(user["level"]) + '\nüí∞ÿ≥⁄©Ÿá üëà ' + str(
            user["coins"]) + '\n\nÿßÿ≥ŸæÿßŸÜÿ≥ÿ± @TRexGames'
        bot.send_message(chat_id=message.chat.id, text=text)
    elif message.text == "üìö ÿ±ÿßŸáŸÜŸÖÿß":
        bot.send_message(chat_id=message.chat.id, text=GUIDE)
    elif message.text == "üèÖ ŸÇŸáÿ±ŸÖÿßŸÜÿßŸÜ":
        user = users_coll.find_one({"_id": message.from_user.id})
        total_rank = user["total_rank"]

        past_seven_days_points = get_past_seven_points(
            games_coll.find({"date": {"$gte": datetime.today().replace(microsecond=0) - timedelta(7)}, "mode": "multi",
                             "users." + str(message.from_user.id): {"$exists": True}},
                            {"users." + str(message.from_user.id) + ".moves": 1}), str(message.from_user.id))
        past_seven_days_rank = get_past_seven_rank(games_coll.find(
            {"date": {"$gte": datetime.today().replace(microsecond=0) - timedelta(7)}, "mode": "multi"}, {"users": 1}),
            str(message.from_user.id))

        markup = types.InlineKeyboardMarkup(row_width=2).add(
            types.InlineKeyboardButton('ÿ±ŸÜ⁄©€åŸÜ⁄Ø ŸáŸÅÿ™ ÿ±Ÿàÿ≤ ÿßÿÆ€åÿ±', callback_data="seven ranking"),
            types.InlineKeyboardButton('ÿ±ŸÜ⁄©€åŸÜ⁄Ø ⁄©ŸÑ', callback_data="total ranking"))

        bot.send_message(chat_id=message.chat.id,
                         text='ŸÇŸáÿ±ŸÖÿßŸÜÿßŸÜ\n\n' + 'üë§ŸÜÿßŸÖ   üëà ' + message.from_user.first_name + '\n\nÿßŸÖÿ™€åÿßÿ≤ ⁄©ŸÑ  üëà ' +
                              str(user["total_point"]) + "\nüî∞ÿ±ÿ™ÿ®Ÿá ⁄©ŸÑ  üëà " + str(
                             total_rank) + "\n\nÿßŸÖÿ™€åÿßÿ≤ ŸáŸÅÿ™ ÿ±Ÿàÿ≤ ÿßÿÆ€åÿ± " + past_seven_days_points + "\nüî∞ ÿ±ÿ™ÿ®Ÿá ŸáŸÅÿ™ ÿ±Ÿàÿ≤ ÿßÿÆ€åÿ± üëà " + past_seven_days_rank + "\n\nÿßÿ≥ŸæÿßŸÜÿ≥ÿ± @TRexGames",
                         reply_markup=markup)
    elif message.text == "üõí ŸÅÿ±Ÿàÿ¥⁄ØÿßŸá":
        users_coll.update_many({}, [{"$set": {"coins": 100}}])
        text = 'üõí ŸÅÿ±Ÿàÿ¥⁄ØÿßŸá\n\nüìöŸáÿ± ÿ±ÿßŸáŸÜŸÖÿß€å ÿ¨ÿßÿ±Ÿà  €åÿß ÿ¨Ÿáÿ¥  5 ÿ≥⁄©Ÿá ŸÜ€åÿßÿ≤ ÿØÿßÿ±ÿØ\n\nüëáÿ®ÿ±ÿß€å ÿÆÿ±€åÿØ ÿ≥⁄©Ÿá €å⁄©€å ÿßÿ≤ ŸÖŸàÿßÿ±ÿØ ÿ≤€åÿ± ÿ±ÿß ' \
               'ÿßŸÜÿ™ÿÆÿßÿ® ŸÜŸÖÿß€å€åÿØüëá '
        markup = types.InlineKeyboardMarkup(row_width=1).add(
            types.InlineKeyboardButton('üí∞ 40 ÿ≥⁄©Ÿáüí∞ üëà 5000 ÿ™ŸàŸÖÿßŸÜ', callback_data='c40'),
            types.InlineKeyboardButton('üí∞ 100 ÿ≥⁄©Ÿáüí∞ üëà 11000 ÿ™ŸàŸÖÿßŸÜ', callback_data='c100'),
            types.InlineKeyboardButton('üí∞ 200 ÿ≥⁄©Ÿáüí∞ üëà 19000 ÿ™ŸàŸÖÿßŸÜ', callback_data='c200'),
            types.InlineKeyboardButton('üí∞ 500 ÿ≥⁄©Ÿáüí∞ üëà 38000 ÿ™ŸàŸÖÿßŸÜ', callback_data='c500'),
            types.InlineKeyboardButton('üí∞ 1000 ÿ≥⁄©Ÿáüí∞ üëà 69000 ÿ™ŸàŸÖÿßŸÜ', callback_data='c1000')
        )

        bot.send_message(chat_id=message.chat.id, text=text, reply_markup=markup)


@bot.chosen_inline_handler(func=lambda message: True)
def handler(message):
    print("chosen", message)
    if bot.get_chat_member(-1001319848880, message.from_user.id).status == 'left':
        markup = types.InlineKeyboardMarkup().add(
            types.InlineKeyboardButton("ÿπÿ∂Ÿà€åÿ™ ÿØÿ± ⁄©ÿßŸÜÿßŸÑ", url="https://t.me/TRexGames"))
        bot.edit_message_text(
            text="⁄©ÿßÿ±ÿ®ÿ± " + message.from_user.first_name + "\nÿ®ÿ±ÿß€å ÿ≥ÿßÿÆÿ™ ÿ®ÿßÿ≤€å ÿßÿ®ÿ™ÿØÿß ÿπÿ∂Ÿà ⁄©ÿßŸÜÿßŸÑ ÿ≤€åÿ± ÿ¥Ÿà€åÿØ üëá\n@TRexGames",
            inline_message_id=message.inline_message_id,
            reply_markup=markup)
        return
    if message.result_id == '6x6h':
        games_id = games_coll.insert_one(
            {"mode": "multi", "type": "hard", "is_complete": 0, "creator": str(message.from_user.id),
             "date": datetime.today().replace(microsecond=0),
             "users": {str(message.from_user.id): {"moves": [], "username": message.from_user.first_name, "jump": 0,
                                                   "broom": 0, "use_broom": 0}}}).inserted_id
        text = "üî¢ ŸÖ€åŸÜ€å ÿ≥ŸàÿØŸà⁄©Ÿà üî¢\n\nüìöŸÇÿ±ÿßÿ±ÿØÿßÿØŸÜ ÿßÿπÿØÿßÿØ 1 ÿ™ÿß 6 ÿØÿ± ÿ¨ÿØŸàŸÑ ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿØÿ± ÿ≥ÿ∑ÿ±ÿå ÿ≥ÿ™ŸàŸÜ Ÿà ŸÖÿ≥ÿ™ÿ∑€åŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá\nüíé ÿ≥ÿ∑ÿ≠ ÿ≥ÿÆÿ™\n\nüî∞ÿßŸÖÿ™€åÿßÿ≤ÿßÿ™\n" + create_text(
            games_coll.find_one({"_id": games_id})["users"]) + '\nü§ñ@MiniSudokuBot'
        bot.edit_message_text(text=text, inline_message_id=message.inline_message_id,
                              reply_markup=create_sudoku(games_id, 'h'))
    elif message.result_id == '6x6e':
        games_id = games_coll.insert_one(
            {"mode": "multi", "type": "easy", "is_complete": 0, "creator": str(message.from_user.id),
             "date": datetime.today().replace(microsecond=0),
             "users": {str(message.from_user.id): {"moves": [], "username": message.from_user.first_name, "jump": 0,
                                                   "broom": 0, "use_broom": 0}}}).inserted_id
        text = "üî¢ ŸÖ€åŸÜ€å ÿ≥ŸàÿØŸà⁄©Ÿà üî¢\n\nüìöŸÇÿ±ÿßÿ±ÿØÿßÿØŸÜ ÿßÿπÿØÿßÿØ 1 ÿ™ÿß 6 ÿØÿ± ÿ¨ÿØŸàŸÑ ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿØÿ± ÿ≥ÿ∑ÿ±ÿå ÿ≥ÿ™ŸàŸÜ Ÿà ŸÖÿ≥ÿ™ÿ∑€åŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá\nüíé ÿ≥ÿ∑ÿ≠ ÿ¢ÿ≥ÿßŸÜ\n\nüî∞ÿßŸÖÿ™€åÿßÿ≤ÿßÿ™\n" + create_text(
            games_coll.find_one({"_id": games_id})["users"]) + '\nü§ñ@MiniSudokuBot'
        bot.edit_message_text(text=text, inline_message_id=message.inline_message_id,
                              reply_markup=create_sudoku(games_id, 'e'))
    elif message.result_id == '6x6m':
        games_id = games_coll.insert_one(
            {"mode": "multi", "type": "medium", "is_complete": 0, "creator": str(message.from_user.id),
             "date": datetime.today().replace(microsecond=0),
             "users": {str(message.from_user.id): {"moves": [], "username": message.from_user.first_name, "jump": 0,
                                                   "broom": 0, "use_broom": 0}}}).inserted_id
        text = "üî¢ ŸÖ€åŸÜ€å ÿ≥ŸàÿØŸà⁄©Ÿà üî¢\n\nüìöŸÇÿ±ÿßÿ±ÿØÿßÿØŸÜ ÿßÿπÿØÿßÿØ 1 ÿ™ÿß 6 ÿØÿ± ÿ¨ÿØŸàŸÑ ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿØÿ± ÿ≥ÿ∑ÿ±ÿå ÿ≥ÿ™ŸàŸÜ Ÿà ŸÖÿ≥ÿ™ÿ∑€åŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá\nüíé ÿ≥ÿ∑ÿ≠ ŸÖÿ™Ÿàÿ≥ÿ∑\n\nüî∞ÿßŸÖÿ™€åÿßÿ≤ÿßÿ™\n" + create_text(
            games_coll.find_one({"_id": games_id})["users"]) + '\nü§ñ@MiniSudokuBot'
        bot.edit_message_text(text=text, inline_message_id=message.inline_message_id,
                              reply_markup=create_sudoku(games_id, 'm'))


@bot.inline_handler(func=lambda query: True)
def inline_handler(message):
    print("inline", message)
    try:
        if len(message.from_user.first_name) > 20:
            message.from_user.first_name = message.from_user.first_name[0:20]
        users_coll.insert_one(
            {"_id": message.from_user.id, "first_name": message.from_user.first_name, "total_point": 0, "coins": 20,
             "level": 0, "total_rank": ''})

    except Exception as e:
        print(e)
    markup = types.InlineKeyboardMarkup().add(
        types.InlineKeyboardButton("‚è≥", callback_data="1"))
    text = "ÿØÿ± ÿ≠ÿßŸÑ ÿ≥ÿßÿÆÿ™..."
    h = types.InlineQueryResultArticle(id='6x6h', title='üî¥ ÿ≥ŸàÿØŸà⁄©Ÿà ÿ≥ÿ∑ÿ≠ ÿ≥ÿÆÿ™',
                                       input_message_content=types.InputTextMessageContent(text),
                                       thumb_url="https://appteams.ir/sudoku/hard.png"
                                       , reply_markup=markup)
    e = types.InlineQueryResultArticle(id='6x6e', title='üü£ ÿ≥ŸàÿØŸà⁄©Ÿà ÿ≥ÿ∑ÿ≠ ÿ≥ÿßÿØŸá',
                                       input_message_content=types.InputTextMessageContent(text),
                                       thumb_url="https://appteams.ir/sudoku/easy.png"
                                       , reply_markup=markup)
    m = types.InlineQueryResultArticle(id='6x6m', title='üü† ÿ≥ŸàÿØŸà⁄©Ÿà ÿ≥ÿ∑ÿ≠ ŸÖÿ™Ÿàÿ≥ÿ∑',
                                       input_message_content=types.InputTextMessageContent(text),
                                       thumb_url="https://appteams.ir/sudoku/medium.png"
                                       , reply_markup=markup)
    bot.answer_inline_query(message.id, [e, m, h])


@bot.callback_query_handler(func=lambda call: True)
def callback_query_handler(call):
    print("call", call)
    try:
        if len(call.from_user.first_name) > 20:
            call.from_user.first_name = call.from_user.first_name[0:20]
        users_coll.insert_one(
            {"_id": call.from_user.id, "first_name": call.from_user.first_name, "total_point": 0,
             "coins": 20,
             "level": 0,
             "total_rank": ''})
    except Exception as e:
        print(e)
    if 'total ranking' == call.data:
        markup = types.InlineKeyboardMarkup(row_width=2).add(
            types.InlineKeyboardButton('ÿ±ŸÜ⁄©€åŸÜ⁄Ø ŸáŸÅÿ™ ÿ±Ÿàÿ≤ ÿßÿÆ€åÿ±', callback_data="seven ranking"),
            types.InlineKeyboardButton('ÿ±ŸÜ⁄©€åŸÜ⁄Ø ⁄©ŸÑ', callback_data="total ranking"))

        text = get_total_ranking(
            users_coll.find({}, {"first_name": 1, "total_point": 1, "total_rank": 1}).sort("total_point", -1).limit(50))

        bot.edit_message_text(chat_id=call.from_user.id, message_id=call.message.message_id, text=text,
                              reply_markup=markup)
    elif call.data == 'shop':
        bot.answer_callback_query(url='t.me/MiniSudokuBot?start=shop', callback_query_id=call.id)
    elif call.data == 'seven ranking':
        markup = types.InlineKeyboardMarkup(row_width=2).add(
            types.InlineKeyboardButton('ÿ±ŸÜ⁄©€åŸÜ⁄Ø ŸáŸÅÿ™ ÿ±Ÿàÿ≤ ÿßÿÆ€åÿ±', callback_data="seven ranking"),
            types.InlineKeyboardButton('ÿ±ŸÜ⁄©€åŸÜ⁄Ø ⁄©ŸÑ', callback_data="total ranking"))

        text = get_seven_ranking(games_coll.find(
            {"date": {"$gte": datetime.today().replace(microsecond=0) - timedelta(7)}, "mode": "multi"},
            {"users": 1}).limit(50))

        bot.edit_message_text(chat_id=call.from_user.id, message_id=call.message.message_id, text=text,
                              reply_markup=markup)
    elif call.data == 'c40' or call.data == 'c100' or call.data == 'c200' or call.data == 'c500' or call.data == 'c1000':
        coins = int(re.sub('c', '', call.data))
        client_id = pays_coll.insert_one({"user_id": call.from_user.id, "coins": coins, "status": "paying",
                                          "date": datetime.today().replace(microsecond=0)}).inserted_id
        headers = {
            "Content-Type": "application/json",
            "Authorization": "Bearer 8a65d585ce24ea37cc87359866f186fcb3ec3782e6b18ac59317188bb5725ab7"
        }
        params = {
            "amount": str(prices[str(coins)]),
            "payerIdentity": "",
            "payerName": "",
            "description": "",
            "returnUrl": "https://appteams.ir/verify-200.html",
            "clientRefId": str(client_id)
        }
        r = requests.post(url="https://api.payping.ir/v1/pay", json=params, headers=headers).json()
        try:
            markup = types.InlineKeyboardMarkup().add(types.InlineKeyboardButton('ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ÿØÿßÿÆÿ™',
                                                                                 url="https://appteams.ir/verify-200.html?code=" +
                                                                                     r["code"] + ""))
            bot.edit_message_text('ÿ®ÿ±ÿß€å ÿ™⁄©ŸÖ€åŸÑ ÿÆÿ±€åÿØ ÿÆŸàÿØ ÿ®ÿ± ÿ±Ÿà€å ÿØ⁄©ŸÖŸá €å ÿ≤€åÿ± ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ:', call.from_user.id,
                                  call.message.id, reply_markup=markup)



        except Exception as e:
            print(e)

    elif 'jump' in call.data or 'broom' in call.data:

        split = call.data.split("/")
        game_id = ObjectId(split[1])
        data = split[0]
        user_id = call.from_user.id
        user = users_coll.find_one({"_id": user_id})
        game = games_coll.find_one({"_id": game_id})
        randomized_sudoku = game["randomized_sudoku"]
        sudoku = game["sudoku"]
        if user_id not in game["users"]:
            games_coll.update_one({"_id": game_id}, {
                "$set": {"users." + user_id: {"moves": [], "username": call.from_user.first_name, "jump": 0,
                                              "broom": 0, "use_broom": 0}}})
            hardness = games_coll.find_one({"_id": game_id})["type"]
            if hardness == 'easy':
                hardness = 'ÿ¢ÿ≥ÿßŸÜ'
            elif hardness == 'medium':
                hardness = 'ŸÖÿ™Ÿàÿ≥ÿ∑'
            else:
                hardness = 'ÿ≥ÿÆÿ™'
            text = "üî¢ ŸÖ€åŸÜ€å ÿ≥ŸàÿØŸà⁄©Ÿà üî¢\n\nüìöŸÇÿ±ÿßÿ±ÿØÿßÿØŸÜ ÿßÿπÿØÿßÿØ 1 ÿ™ÿß 6 ÿØÿ± ÿ¨ÿØŸàŸÑ ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿØÿ± ÿ≥ÿ∑ÿ±ÿå ÿ≥ÿ™ŸàŸÜ Ÿà ŸÖÿ≥ÿ™ÿ∑€åŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá\nüíé ÿ≥ÿ∑ÿ≠ " + hardness + "\n\nüî∞ÿßŸÖÿ™€åÿßÿ≤ÿßÿ™\n" + create_text(
                games_coll.find_one({"_id": game_id})["users"]) + '\nü§ñ@MiniSudokuBot'
            if len(games_coll.find_one({"_id": game_id})["users"]) == 2:
                bot.edit_message_text(text=text, inline_message_id=call.inline_message_id,
                                      reply_markup=create_keyboards(randomized_sudoku, str(game_id)))
            game = games_coll.find_one({"_id": game_id})
        if (game["users"][str(user_id)]["jump"] == 1 and data == 'jump') or (
                game["users"][str(user_id)]["broom"] == 1 and data == 'broom' and game["users"][str(user_id)][
            "use_broom"] == 0):
            bot.answer_callback_query(text='ÿ¥ŸÖÿß ŸÇÿ®ŸÑÿß ÿßÿ≤ ÿß€åŸÜ ÿ¢€åÿ™ŸÖ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ÿ±ÿØŸá ÿß€åÿØ.', callback_query_id=call.id)
            return
        if user["coins"] < 5:
            bot.answer_callback_query(call.id, 'ÿ¥ŸÖÿß ÿ≥⁄©Ÿá €å ⁄©ÿßŸÅ€å ÿ®ÿ±ÿß€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ÿß€åŸÜ ÿ¢€åÿ™ŸÖ ÿ±ÿß ŸÜÿØÿßÿ±€åÿØ.')
            return
        if data == 'jump':
            zero_indices = []
            for i, row in enumerate(randomized_sudoku):
                for j, element in enumerate(row):
                    if element == 0:
                        zero_indices.append(i * 6 + j)
            index = zero_indices[random.randint(0, len(zero_indices) - 1)]
            i = index // 6
            j = index % 6
            call.data = 'n' + str(sudoku[i][j]) + "/" + str(game_id)
            length = len(game["users"][str(user_id)]["moves"])
            moves = game["users"][str(user_id)]["moves"]
            games_coll.update_one({"_id": game_id}, {"$set": {"users." + str(call.from_user.id) + ".jump": 1}})
            if len(moves) == 0 or moves[length - 1]["n"] != 0:
                games_coll.update_one({"_id": game_id},
                                      {"$push": {
                                          "users." + str(call.from_user.id) + ".moves": {"i": i,
                                                                                         "j": j,
                                                                                         "n": 0,
                                                                                         "point": 0
                                                                                         }}})
            else:
                games_coll.update_one({"_id": game_id},
                                      {"$set": {
                                          "users." + str(call.from_user.id) + ".moves." + str(length - 1): {
                                              "i": i,
                                              "j": j,
                                              "n": 0,
                                              "point": 0

                                          }
                                      }})
            users_coll.update_one({"_id": call.from_user.id}, {"$inc": {"coins": -5}})
        elif data == 'broom':
            games_coll.update_one({"_id": game_id}, {"$set": {"users." + str(call.from_user.id) + ".broom": 1,
                                                              "users." + str(call.from_user.id) + ".use_broom": 1}})
            bot.answer_callback_query(call.id, 'ÿ≠ÿßŸÑÿß €å⁄© ÿÆŸàŸÜŸá ÿ±Ÿà ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ!')

    if re.search(r's[0-5][0-5]', call.data) or re.search(r'n[1-6]', call.data):
        game_id = str(call.data).split("/")[1]
        game_id = ObjectId(game_id)
        user_id = str(call.from_user.id)
        doc = games_coll.find_one({"_id": game_id})
        length = 0
        randomized_sudoku = doc["randomized_sudoku"]
        # print_sudoku(randomized_sudoku)
        if doc["mode"] == "multi":
            if user_id not in doc["users"]:
                games_coll.update_one({"_id": game_id}, {
                    "$set": {"users." + user_id: {"moves": [], "username": call.from_user.first_name, "jump": 0,
                                                  "broom": 0, "use_broom": 0}}})
                hardness = games_coll.find_one({"_id": game_id})["type"]
                if hardness == 'easy':
                    hardness = 'ÿ¢ÿ≥ÿßŸÜ'
                elif hardness == 'medium':
                    hardness = 'ŸÖÿ™Ÿàÿ≥ÿ∑'
                else:
                    hardness = 'ÿ≥ÿÆÿ™'
                text = "üî¢ ŸÖ€åŸÜ€å ÿ≥ŸàÿØŸà⁄©Ÿà üî¢\n\nüìöŸÇÿ±ÿßÿ±ÿØÿßÿØŸÜ ÿßÿπÿØÿßÿØ 1 ÿ™ÿß 6 ÿØÿ± ÿ¨ÿØŸàŸÑ ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿØÿ± ÿ≥ÿ∑ÿ±ÿå ÿ≥ÿ™ŸàŸÜ Ÿà ŸÖÿ≥ÿ™ÿ∑€åŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá\nüíé ÿ≥ÿ∑ÿ≠ " + hardness + "\n\nüî∞ÿßŸÖÿ™€åÿßÿ≤ÿßÿ™\n" + create_text(
                    games_coll.find_one({"_id": game_id})["users"]) + '\nü§ñ@MiniSudokuBot'
                if len(games_coll.find_one({"_id": game_id})["users"]) == 2:
                    bot.edit_message_text(text=text, inline_message_id=call.inline_message_id,
                                          reply_markup=create_keyboards(randomized_sudoku, str(game_id)))
                doc = games_coll.find_one({"_id": game_id})
            if len(doc["users"]) == 1:
                bot.answer_callback_query(call.id, "ÿßŸàŸÑ ÿØ€å⁄Øÿ± ÿ®ÿßÿ≤€å⁄©ŸÜÿßŸÜ ÿ®ÿß€åÿØ ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜŸÜÿØ!")
                return
        status = doc["is_complete"]
        moves = games_coll.find_one({"_id": game_id})["users"][str(call.from_user.id)]["moves"]
        length = len(moves)
        if status == 1:
            bot.answer_callback_query(call.id, "ÿ®ÿßÿ≤€å ÿ™ŸÖÿßŸÖ ÿ¥ÿØŸá ÿßÿ≥ÿ™!")
            return
        sudoku = doc["sudoku"]
        if re.search(r's[0-5][0-5]', call.data):
            soduku_id = str(call.data).split("/")[0]
            indices = [int(i) for i in re.sub(r's', '', soduku_id)]
            if randomized_sudoku[indices[0]][indices[1]] != 0:
                bot.answer_callback_query(call.id, "ÿß€åŸÜ ÿÆÿßŸÜŸá ÿÆÿßŸÑ€å ŸÜ€åÿ≥ÿ™!")
                return
            else:
                if length == 0:
                    games_coll.update_one({"_id": game_id},
                                          {"$push": {
                                              "users." + str(call.from_user.id) + ".moves": {"i": indices[0],
                                                                                             "j": indices[1],
                                                                                             "n": 0,
                                                                                             "point": 0
                                                                                             }}})
                elif moves[length - 1]["n"] == 0:
                    games_coll.update_one({"_id": game_id},
                                          {"$set": {
                                              "users." + str(call.from_user.id) + ".moves." + str(length - 1): {
                                                  "i": indices[0],
                                                  "j": indices[1],
                                                  "n": 0,
                                                  "point": 0

                                              }
                                          }})
                else:
                    games_coll.update_one({"_id": game_id},
                                          {"$push": {
                                              "users." + str(call.from_user.id) + ".moves": {"i": indices[0],
                                                                                             "j": indices[1],
                                                                                             "n": 0,
                                                                                             "point": 0
                                                                                             }}})
                if doc["users"][str(call.from_user.id)]["broom"] == 1 and doc["users"][str(call.from_user.id)][
                    "use_broom"] == 1:
                    call.data = 'n' + str(sudoku[indices[0]][indices[1]]) + '/' + str(soduku_id)
                    games_coll.update_one({"_id": game_id},
                                          {"$set": {"users." + str(call.from_user.id) + ".use_broom": 0}})
                    users_coll.update_one({"_id": call.from_user.id}, {"$inc": {"coins": -5}})
                else:
                    bot.answer_callback_query(call.id, "ÿ≠ÿßŸÑÿß ÿπÿØÿØ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ±ÿ™ ÿ±Ÿà ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ")
        if re.search(r'n[1-6]', call.data):
            moves = games_coll.find_one({"_id": game_id})["users"][str(call.from_user.id)]["moves"]
            length = len(moves)
            if length == 0:
                bot.answer_callback_query(call.id, "ÿ¥ŸÖÿß ŸáŸÜŸàÿ≤ ÿÆÿßŸÜŸá ÿß€å ÿßŸÜÿ™ÿÆÿßÿ® ŸÜ⁄©ÿ±ÿØ€åÿØ!")
                return
            elif moves[length - 1]["n"] != 0:
                bot.answer_callback_query(call.id, "ÿ¥ŸÖÿß ŸáŸÜŸàÿ≤ ÿÆÿßŸÜŸá ÿß€å ÿßŸÜÿ™ÿÆÿßÿ® ŸÜ⁄©ÿ±ÿØ€åÿØ!")
            elif moves[length - 1]["n"] == 0:
                numbers_id = str(call.data).split("/")[0]
                number = re.sub(r'n', '', numbers_id)
                number = int(number)
                i = moves[length - 1]["i"]
                j = moves[length - 1]["j"]
                if randomized_sudoku[i][j] != 0:
                    bot.answer_callback_query(call.id, 'ÿß€åŸÜ ÿÆÿßŸÜŸá ÿÆÿßŸÑ€å ŸÜ€åÿ≥ÿ™!')
                elif randomized_sudoku[i][j] == 0 and sudoku[i][j] == number:
                    randomized_sudoku[i][j] = number
                    games_coll.update_one({"_id": game_id}, {"$set": {"randomized_sudoku": randomized_sudoku}})
                    point = 0
                    if length != 0:
                        for k in moves:
                            point += k["point"]
                    games_coll.update_one({"_id": game_id},
                                          {"$set": {
                                              "users." + str(call.from_user.id) + ".moves." + str(length - 1): {
                                                  "i": i,
                                                  "j": j,
                                                  "n": number,
                                                  "point": 3
                                              }
                                          }})
                    if randomized_sudoku == sudoku:
                        print('ended!')
                        if doc["mode"] == 'single':
                            text = "üî¢ ŸÖ€åŸÜ€å ÿ≥ŸàÿØŸà⁄©Ÿà üî¢\n\nüìöŸÇÿ±ÿßÿ±ÿØÿßÿØŸÜ ÿßÿπÿØÿßÿØ 1 ÿ™ÿß 6 ÿØÿ± ÿ¨ÿØŸàŸÑ ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿØÿ± ÿ≥ÿ∑ÿ±ÿå ÿ≥ÿ™ŸàŸÜ Ÿà ŸÖÿ≥ÿ™ÿ∑€åŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá\nüíé ÿ®ÿßÿ≤€å ÿßŸÜŸÅÿ±ÿßÿØ€å" + "\n\nüáÆüá∑Ÿæÿß€åÿßŸÜ ÿ®ÿßÿ≤€åüáÆüá∑\n" + create_text(
                                games_coll.find_one({"_id": game_id})["users"]) + '\nü§ñ@MiniSudokuBot'
                            bot.edit_message_text(text,
                                                  call.from_user.id,
                                                  call.message.message_id,
                                                  reply_markup=create_finish_keyboards(sudoku))
                            status = 1
                            games_coll.update_one({"_id": game_id},
                                                  {"$set": {"status": status}})
                        else:
                            hardness = games_coll.find_one({"_id": game_id})["type"]
                            print('ended!-1 ' + str(game_id))
                            if hardness == 'easy':
                                hardness = 'ÿ¢ÿ≥ÿßŸÜ'
                            elif hardness == 'medium':
                                hardness = 'ŸÖÿ™Ÿàÿ≥ÿ∑'
                            else:
                                hardness = 'ÿ≥ÿÆÿ™'
                            points = {}
                            game = games_coll.find_one({"_id": game_id})
                            print('ended!-2 ' + str(game_id))
                            for i in game["users"]:
                                if len(game["users"][i]["moves"]) == 0:
                                    points[game["users"][i]["username"]] = 0
                                else:
                                    point = 0
                                    for x in game["users"][i]["moves"]:
                                        point += x["point"]
                                    points[game["users"][i]["username"]] = point
                            print('ended!-3 ' + str(game_id))
                            points = dict(sorted(points.items(), key=lambda x: x[1], reverse=True))
                            text = "üî¢ ŸÖ€åŸÜ€å ÿ≥ŸàÿØŸà⁄©Ÿà üî¢\n\nüìöŸÇÿ±ÿßÿ±ÿØÿßÿØŸÜ ÿßÿπÿØÿßÿØ 1 ÿ™ÿß 6 ÿØÿ± ÿ¨ÿØŸàŸÑ ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿØÿ± ÿ≥ÿ∑ÿ±ÿå ÿ≥ÿ™ŸàŸÜ Ÿà ŸÖÿ≥ÿ™ÿ∑€åŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá\nüíé ÿ≥ÿ∑ÿ≠ " + hardness + "\n\nüáÆüá∑Ÿæÿß€åÿßŸÜ ÿ®ÿßÿ≤€åüáÆüá∑\n" + create_text(
                                games_coll.find_one({"_id": game_id})["users"]) + '\nüèÜ ÿß€åŸÜ ÿ®ÿßÿ≤€å ÿ®ÿß ÿ®ÿ±ÿ™ÿ±€å ' + \
                                   list(points.keys())[0] + ' ÿ®Ÿá Ÿæÿß€åÿßŸÜ ÿ±ÿ≥€åÿØüëèüï∫üíÉ\nü§ñ@MiniSudokuBot'
                            print('ended!-4 ' + str(game_id))
                            update_profiles(games_coll.find_one({"_id": game_id})["users"], game_id)
                            print('ended!-5 ' + str(game_id))
                            bot.edit_message_text(text=text, inline_message_id=call.inline_message_id,
                                                  reply_markup=create_finish_keyboards(sudoku))
                            print('ended!-6 ' + str(game_id))
                    else:
                        if doc["mode"] == 'single':
                            text = "üî¢ ŸÖ€åŸÜ€å ÿ≥ŸàÿØŸà⁄©Ÿà üî¢\n\nüìöŸÇÿ±ÿßÿ±ÿØÿßÿØŸÜ ÿßÿπÿØÿßÿØ 1 ÿ™ÿß 6 ÿØÿ± ÿ¨ÿØŸàŸÑ ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿØÿ± ÿ≥ÿ∑ÿ±ÿå ÿ≥ÿ™ŸàŸÜ Ÿà ŸÖÿ≥ÿ™ÿ∑€åŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá\nüíé ÿ®ÿßÿ≤€å ÿßŸÜŸÅÿ±ÿßÿØ€å" + "\n\nüî∞ÿßŸÖÿ™€åÿßÿ≤ÿßÿ™\n" + create_text(
                                games_coll.find_one({"_id": game_id})["users"]) + '\nü§ñ@MiniSudokuBot'
                            bot.edit_message_text(text=
                                                  text,
                                                  chat_id=call.from_user.id,
                                                  message_id=call.message.message_id,
                                                  reply_markup=create_keyboards(randomized_sudoku, str(game_id)))
                        else:
                            hardness = games_coll.find_one({"_id": game_id})["type"]
                            if hardness == 'easy':
                                hardness = 'ÿ¢ÿ≥ÿßŸÜ'
                            elif hardness == 'medium':
                                hardness = 'ŸÖÿ™Ÿàÿ≥ÿ∑'
                            else:
                                hardness = 'ÿ≥ÿÆÿ™'
                            text = "üî¢ ŸÖ€åŸÜ€å ÿ≥ŸàÿØŸà⁄©Ÿà üî¢\n\nüìöŸÇÿ±ÿßÿ±ÿØÿßÿØŸÜ ÿßÿπÿØÿßÿØ 1 ÿ™ÿß 6 ÿØÿ± ÿ¨ÿØŸàŸÑ ÿ®ÿØŸàŸÜ ÿ™⁄©ÿ±ÿßÿ± ÿØÿ± ÿ≥ÿ∑ÿ±ÿå ÿ≥ÿ™ŸàŸÜ Ÿà ŸÖÿ≥ÿ™ÿ∑€åŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá\nüíé ÿ≥ÿ∑ÿ≠ " + hardness + "\n\nüî∞ÿßŸÖÿ™€åÿßÿ≤ÿßÿ™\n" + create_text(
                                games_coll.find_one({"_id": game_id})["users"]) + '\nü§ñ@MiniSudokuBot'
                            bot.edit_message_text(text=text, inline_message_id=call.inline_message_id,
                                                  reply_markup=create_keyboards(randomized_sudoku, str(game_id)))
                        bot.answer_callback_query(call.id, "ÿ¢ŸÅÿ±€åŸÜ!üëç")

                else:
                    point = 0
                    if length != 0:
                        for k in moves:
                            point += k["point"]
                    games_coll.update_one({"_id": game_id},
                                          {"$set": {
                                              "users." + str(call.from_user.id) + ".moves." + str(length - 1): {
                                                  "i": i,
                                                  "j": j,
                                                  "n": number,
                                                  "point": -2
                                              }
                                          }})
                    bot.answer_callback_query(call.id, "Ÿàÿßÿß€åüò¢")





bot.polling()




